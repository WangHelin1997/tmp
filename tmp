H = self.hop_size
W = self.win_size
N = (est_targets.shape[-1] - W) // F + 1
B = est_targets.shape[0]
en_thres = self.en_thres
snr_thres = self.snr_thres
alpha, beta, gamma = self.alpha, self.beta, self.gamma

enh_loss = 0.

for i in range(B):
    
    est_targets_segments = est_targets[i].squeeze().unfold(0, W, H)
    targets_segments = targets[i].squeeze().unfold(0, W, H)
    
    en_targets_segments = torch.sum(est_targets_segments**2, dim=1) / H
    est_targets_segments = est_targets_segments[en_targets_segments > en_thres]
    targets_segments = targets_segments[en_targets_segments > en_thres]
    others_segments = others_segments[en_targets_segments > en_thres]
    
    snr = singlesrc_neg_sisdr(est_targets_segments, targets_segments)
    snr2 = singlesrc_neg_sisdr(est_targets_segments, others_segments)
    
    enh_loss += self.alpha * snr[snr>snr_thres] + \
        self.beta * snr_thres[(snr<snr_thres) & (snr>snr2)] + \
        self.gamma * snr_thres[(snr<snr_thres) & (snr<=snr2)]

enh_loss /= B
